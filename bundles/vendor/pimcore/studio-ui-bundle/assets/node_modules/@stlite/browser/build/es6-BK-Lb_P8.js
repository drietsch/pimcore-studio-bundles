var se=Object.defineProperty;var $=c=>{throw TypeError(c)};var le=(c,y,d)=>y in c?se(c,y,{enumerable:!0,configurable:!0,writable:!0,value:d}):c[y]=d;var S=(c,y,d)=>le(c,typeof y!="symbol"?y+"":y,d),ce=(c,y,d)=>y.has(c)||$("Cannot "+d);var V=(c,y,d)=>y.has(c)?$("Cannot add the same private member more than once"):y instanceof WeakSet?y.add(c):y.set(c,d),Y=(c,y,d,v)=>(ce(c,y,"write to private field"),v?v.call(c,d):y.set(c,d),d);let X,N,D,ye=(async()=>{var x,R,U,B,C,G;const c=globalThis.showDirectoryPicker;async function y(n={}){if(c&&!n._preferPolyfill)return c(n);const t=document.createElement("input");t.type="file",t.webkitdirectory=!0,t.multiple=!0,t.style.position="fixed",t.style.top="-100000px",t.style.left="-100000px",document.body.appendChild(t);const e=Promise.resolve().then(()=>z);return await new Promise(a=>{t.addEventListener("change",a),t.click()}),e.then(a=>a.getDirHandlesFromInput(t))}const d={accepts:[]},v=globalThis.showOpenFilePicker;async function J(n={}){const t={...d,...n};if(v&&!n._preferPolyfill)return v(t);const e=document.createElement("input");e.type="file",e.multiple=t.multiple,e.accept=(t.accepts||[]).map(r=>[...(r.extensions||[]).map(o=>"."+o),...r.mimeTypes||[]]).flat().join(","),Object.assign(e.style,{position:"fixed",top:"-100000px",left:"-100000px"}),document.body.appendChild(e);const a=Promise.resolve().then(()=>z);return await new Promise(r=>{e.addEventListener("change",r,{once:!0}),e.click()}),e.remove(),a.then(r=>r.getFileHandlesFromInput(e))}const W=globalThis.showSaveFilePicker;async function K(n={}){if(W&&!n._preferPolyfill)return W(n);n._name&&(console.warn("deprecated _name, spec now have `suggestedName`"),n.suggestedName=n._name);const{FileSystemFileHandle:t}=await Promise.resolve().then(()=>h),{FileHandle:e}=await import("./downloader-CwLkQ96f.js");return new t(new e(n.suggestedName))}globalThis.DataTransferItem&&!DataTransferItem.prototype.getAsFileSystemHandle&&(DataTransferItem.prototype.getAsFileSystemHandle=async function(){const n=this.webkitGetAsEntry(),[{FileHandle:t,FolderHandle:e},{FileSystemDirectoryHandle:a},{FileSystemFileHandle:r}]=await Promise.all([import("./sandbox-cy7Awv1w.js"),Promise.resolve().then(()=>k),Promise.resolve().then(()=>h)]);return n.isFile?new r(new t(n,!1)):new a(new e(n,!1))});async function Q(n,t={}){var o,s;if(!n)return((s=(o=globalThis.navigator)==null?void 0:o.storage)==null?void 0:s.getDirectory())||globalThis.getOriginPrivateDirectory();const{FileSystemDirectoryHandle:e}=await Promise.resolve().then(()=>k),a=await n,r=await(a.default?a.default(t):a(t));return new e(r)}let L;N={ReadableStream:globalThis.ReadableStream,WritableStream:globalThis.WritableStream,TransformStream:globalThis.TransformStream,DOMException:globalThis.DOMException,Blob:globalThis.Blob,File:globalThis.File},{WritableStream:L}=N;const I=class I extends L{constructor(e){super(e);V(this,x);Y(this,x,e),Object.setPrototypeOf(this,I.prototype),this._closed=!1}async close(){this._closed=!0;const e=this.getWriter(),a=e.close();return e.releaseLock(),a}seek(e){return this.write({type:"seek",position:e})}truncate(e){return this.write({type:"truncate",size:e})}write(e){if(this._closed)return Promise.reject(new TypeError("Cannot write to a CLOSED writable stream"));const a=this.getWriter(),r=a.write(e);return a.releaseLock(),r}};x=new WeakMap;let u=I;Object.defineProperty(u.prototype,Symbol.toStringTag,{value:"FileSystemWritableFileStream",writable:!1,enumerable:!1,configurable:!0}),Object.defineProperties(u.prototype,{close:{enumerable:!0},seek:{enumerable:!0},truncate:{enumerable:!0},write:{enumerable:!0}}),globalThis.FileSystemFileHandle&&!globalThis.FileSystemFileHandle.prototype.createWritable&&!globalThis.FileSystemWritableFileStream&&(globalThis.FileSystemWritableFileStream=u);const w=Symbol("adapter");R=w;class O{constructor(t){S(this,R);S(this,"name");S(this,"kind");this.kind=t.kind,this.name=t.name,this[w]=t}async queryPermission(t={}){const{mode:e="read"}=t,a=this[w];if(a.queryPermission)return a.queryPermission({mode:e});if(e==="read")return"granted";if(e==="readwrite")return a.writable?"granted":"denied";throw new TypeError(`Mode ${e} must be 'read' or 'readwrite'`)}async requestPermission({mode:t="read"}={}){const e=this[w];if(e.requestPermission)return e.requestPermission({mode:t});if(t==="read")return"granted";if(t==="readwrite")return e.writable?"granted":"denied";throw new TypeError(`Mode ${t} must be 'read' or 'readwrite'`)}async remove(t={}){await this[w].remove(t)}async isSameEntry(t){return this===t?!0:!t||typeof t!="object"||this.kind!==t.kind||!t[w]?!1:this[w].isSameEntry(t[w])}}Object.defineProperty(O.prototype,Symbol.toStringTag,{value:"FileSystemHandle",writable:!1,enumerable:!1,configurable:!0}),globalThis.FileSystemHandle&&((U=globalThis.FileSystemHandle.prototype).queryPermission??(U.queryPermission=function(n){return"granted"}));let q;D={INVALID:["seeking position failed.","InvalidStateError"],GONE:["A requested file or directory could not be found at the time an operation was processed.","NotFoundError"],MISMATCH:["The path supplied exists, but was not an entry of requested type.","TypeMismatchError"],MOD_ERR:["The object can not be modified in this way.","InvalidModificationError"],SYNTAX:n=>[`Failed to execute 'write' on 'UnderlyingSinkBase': Invalid params passed. ${n}`,"SyntaxError"],SECURITY:["It was determined that certain files are unsafe for access within a Web application, or that too many calls are being made on file resources.","SecurityError"],DISALLOWED:["The request is not allowed by the user agent or the platform in the current context.","NotAllowedError"]},q={writable:globalThis.WritableStream};async function Z(n){console.warn("deprecated fromDataTransfer - use `dt.items[0].getAsFileSystemHandle()` instead");const[t,e,a]=await Promise.all([import("./memory-BUE9KRix.js"),import("./sandbox-cy7Awv1w.js"),Promise.resolve().then(()=>k)]),r=new t.FolderHandle("",!1);return r._entries=n.map(o=>o.isFile?new e.FileHandle(o,!1):new e.FolderHandle(o,!1)),new a.FileSystemDirectoryHandle(r)}async function ee(n){const{FolderHandle:t,FileHandle:e}=await import("./memory-BUE9KRix.js"),{FileSystemDirectoryHandle:a}=await Promise.resolve().then(()=>k),r=Array.from(n.files),o=r[0].webkitRelativePath.split("/",1)[0],s=new t(o,!1);return r.forEach(p=>{const l=p.webkitRelativePath.split("/");l.shift();const m=l.pop(),b=l.reduce((g,F)=>(g._entries[F]||(g._entries[F]=new t(F,!1)),g._entries[F]),s);b._entries[m]=new e(p.name,p,!1)}),new a(s)}async function te(n){const{FileHandle:t}=await import("./memory-BUE9KRix.js"),{FileSystemFileHandle:e}=await Promise.resolve().then(()=>h);return Array.from(n.files).map(a=>new e(new t(a.name,a,!1)))}const z=Object.freeze(Object.defineProperty({__proto__:null,config:q,errors:D,fromDataTransfer:Z,getDirHandlesFromInput:ee,getFileHandlesFromInput:te},Symbol.toStringTag,{value:"Module"})),{GONE:ae,MOD_ERR:ie}=D,f=Symbol("adapter");let T=class M extends O{constructor(e){super(e);S(this,B);this[f]=e}async getDirectoryHandle(e,a={}){if(e==="")throw new TypeError("Name can't be an empty string.");if(e==="."||e===".."||e.includes("/"))throw new TypeError("Name contains invalid characters.");a.create=!!a.create;const r=await this[f].getDirectoryHandle(e,a);return new M(r)}async*entries(){const{FileSystemFileHandle:e}=await Promise.resolve().then(()=>h);for await(const[a,r]of this[f].entries())yield[r.name,r.kind==="file"?new e(r):new M(r)]}async*getEntries(){const{FileSystemFileHandle:e}=await Promise.resolve().then(()=>h);console.warn("deprecated, use .entries() instead");for await(let a of this[f].entries())yield a.kind==="file"?new e(a):new M(a)}async getFileHandle(e,a={}){const{FileSystemFileHandle:r}=await Promise.resolve().then(()=>h);if(e==="")throw new TypeError("Name can't be an empty string.");if(e==="."||e===".."||e.includes("/"))throw new TypeError("Name contains invalid characters.");a.create=!!a.create;const o=await this[f].getFileHandle(e,a);return new r(o)}async removeEntry(e,a={}){if(e==="")throw new TypeError("Name can't be an empty string.");if(e==="."||e===".."||e.includes("/"))throw new TypeError("Name contains invalid characters.");return a.recursive=!!a.recursive,this[f].removeEntry(e,a)}async resolve(e){if(await e.isSameEntry(this))return[];const a=[{handle:this,path:[]}];for(;a.length;){let{handle:r,path:o}=a.pop();for await(const s of r.values()){if(await s.isSameEntry(e))return[...o,s.name];s.kind==="directory"&&a.push({handle:s,path:[...o,s.name]})}}return null}async*keys(){for await(const[e]of this[f].entries())yield e}async*values(){for await(const[e,a]of this)yield a}[(B=f,Symbol.asyncIterator)](){return this.entries()}};if(Object.defineProperty(T.prototype,Symbol.toStringTag,{value:"FileSystemDirectoryHandle",writable:!1,enumerable:!1,configurable:!0}),Object.defineProperties(T.prototype,{getDirectoryHandle:{enumerable:!0},entries:{enumerable:!0},getFileHandle:{enumerable:!0},removeEntry:{enumerable:!0}}),globalThis.FileSystemDirectoryHandle){const n=globalThis.FileSystemDirectoryHandle.prototype;n.resolve=async function(r){if(await r.isSameEntry(this))return[];const o=[{handle:this,path:[]}];for(;o.length;){let{handle:s,path:p}=o.pop();for await(const l of s.values()){if(await l.isSameEntry(r))return[...p,l.name];l.kind==="directory"&&o.push({handle:l,path:[...p,l.name]})}}return null};async function t(r){if(await(await navigator.storage.getDirectory()).resolve(r)===null)throw new DOMException(...ae)}const e=n.entries;n.entries=async function*(){await t(this),yield*e.call(this)},n[Symbol.asyncIterator]=async function*(){yield*this.entries()};const a=n.removeEntry;n.removeEntry=async function(r,o={}){return a.call(this,r,o).catch(async s=>{throw s instanceof DOMException&&s.name==="UnknownError"&&!o.recursive&&!(await e.call(this).next()).done?new DOMException(...ie):s})}}const k=Object.freeze(Object.defineProperty({__proto__:null,FileSystemDirectoryHandle:T,default:T},Symbol.toStringTag,{value:"Module"})),{INVALID:re,SYNTAX:j,GONE:ne}=D,_=Symbol("adapter");class H extends(G=O,C=_,G){constructor(e){super(e);S(this,C);this[_]=e}async createWritable(e={}){return new u(await this[_].createWritable(e))}async getFile(){return this[_].getFile()}}if(Object.defineProperty(H.prototype,Symbol.toStringTag,{value:"FileSystemFileHandle",writable:!1,enumerable:!1,configurable:!0}),Object.defineProperties(H.prototype,{createWritable:{enumerable:!0},getFile:{enumerable:!0}}),globalThis.FileSystemFileHandle&&!globalThis.FileSystemFileHandle.prototype.createWritable){const n=new WeakMap;let t;const e=()=>{let r,o;onmessage=async s=>{const p=s.ports[0],l=s.data;switch(l.type){case"open":const m=l.name;let b=await navigator.storage.getDirectory();for(const g of l.path)b=await b.getDirectoryHandle(g);r=await b.getFileHandle(m),o=await r.createSyncAccessHandle();break;case"write":o.write(l.data,{at:l.position}),o.flush();break;case"truncate":o.truncate(l.size);break;case"abort":case"close":o.close();break}p.postMessage(0)}};globalThis.FileSystemFileHandle.prototype.createWritable=async function(r){if(!t){const i=`(${e.toString()})()`,E=new Blob([i],{type:"text/javascript"});t=URL.createObjectURL(E)}const o=new Worker(t,{type:"module"});let s=0;const p=new TextEncoder;let l=await this.getFile().then(i=>i.size);const m=i=>new Promise((E,oe)=>{const P=new MessageChannel;P.port1.onmessage=A=>{A.data instanceof Error?oe(A.data):E(A.data),P.port1.close(),P.port2.close(),P.port1.onmessage=null},o.postMessage(i,[P.port2])}),b=await navigator.storage.getDirectory(),g=await n.get(this),F=await b.resolve(g);if(F===null)throw new DOMException(...ne);return await m({type:"open",path:F,name:this.name}),(r==null?void 0:r.keepExistingData)===!1&&(await m({type:"truncate",size:0}),l=0),new u({start:i=>{},async write(i){if((i==null?void 0:i.constructor)===Object?i={...i}:i={type:"write",data:i,position:s},i.type==="write"){if(!("data"in i))throw await m({type:"close"}),new DOMException(...j("write requires a data argument"));if(i.position??(i.position=s),typeof i.data=="string")i.data=p.encode(i.data);else if(i.data instanceof ArrayBuffer)i.data=new Uint8Array(i.data);else if(!(i.data instanceof Uint8Array)&&ArrayBuffer.isView(i.data))i.data=new Uint8Array(i.data.buffer,i.data.byteOffset,i.data.byteLength);else if(!(i.data instanceof Uint8Array)){const E=await new Response(i.data).arrayBuffer();i.data=new Uint8Array(E)}Number.isInteger(i.position)&&i.position>=0&&(s=i.position),s+=i.data.byteLength,l+=i.data.byteLength}else if(i.type==="seek")if(Number.isInteger(i.position)&&i.position>=0){if(l<i.position)throw new DOMException(...re);console.log("seeking",i),s=i.position;return}else throw await m({type:"close"}),new DOMException(...j("seek requires a position argument"));else if(i.type==="truncate")if(Number.isInteger(i.size)&&i.size>=0)l=i.size,s>l&&(s=l);else throw await m({type:"close"}),new DOMException(...j("truncate requires a size argument"));await m(i)},async close(){await m({type:"close"}),o.terminate()},async abort(i){await m({type:"abort",reason:i}),o.terminate()}})};const a=FileSystemDirectoryHandle.prototype.getFileHandle;FileSystemDirectoryHandle.prototype.getFileHandle=async function(...r){const o=await a.call(this,...r);return n.set(o,this),o}}let h;h=Object.freeze(Object.defineProperty({__proto__:null,FileSystemFileHandle:H,default:H},Symbol.toStringTag,{value:"Module"})),X=Object.freeze(Object.defineProperty({__proto__:null,FileSystemDirectoryHandle:T,FileSystemFileHandle:H,FileSystemHandle:O,FileSystemWritableFileStream:u,getOriginPrivateDirectory:Q,showDirectoryPicker:y,showOpenFilePicker:J,showSaveFilePicker:K},Symbol.toStringTag,{value:"Module"}))})();export{ye as __tla,X as a,N as c,D as e};
